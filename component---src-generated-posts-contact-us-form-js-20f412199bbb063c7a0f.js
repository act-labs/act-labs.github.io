(window.webpackJsonp=window.webpackJsonp||[]).push([[13],{728:function(e,t,n){"use strict";n.r(t);var a=n(0),o=n.n(a),r=n(14),s=n.n(r),i=n(15),c=n.n(i),l=n(1),m=function(e){function t(t){var n;return(n=e.call(this,t)||this).layout=null,n}return c()(t,e),t.prototype.render=function(){var e=this.props,t=e.components;s()(e,["components"]);return o.a.createElement(l.MDXTag,{name:"wrapper",components:t},o.a.createElement(l.MDXTag,{name:"p",components:t},"Lets create a simple Contact us form using TDD and Jest. Assuming we have developed some ",o.a.createElement(l.MDXTag,{name:"a",components:t,parentName:"p",props:{href:"/posts/form-components/",title:"Simple form implementation from scratch"}},"form components")," (or borrowed them from numerous component libraries available), we may turn our attention to the application logic (validation and communication with server). In other blog post I also consider ",o.a.createElement(l.MDXTag,{name:"a",components:t,parentName:"p",props:{href:"/posts/mysql-express/",title:"Express and MySql. Simple Contact Us form"}},"server side implementation")," (using Express and MySQL). Source code could be found on ",o.a.createElement(l.MDXTag,{name:"a",components:t,parentName:"p",props:{href:"https://github.com/act-labs/contact-us",title:"Sample contact-us app using React/MySql/Express"}},"Github"),"."),o.a.createElement(l.MDXTag,{name:"h2",components:t},"Simple contact us form"),o.a.createElement(l.MDXTag,{name:"p",components:t},"Our simple form enabling users to send us messages along with their contact details. Here I paid little attention to the form design (which later could be tweaked through CSS styles anyway). Main focus is functionality: validation and communication with server. Our component looks as follows:"),o.a.createElement(l.MDXTag,{name:"pre",components:t},o.a.createElement(l.MDXTag,{name:"code",components:t,parentName:"pre",props:{className:"language-javascript"}},'const App = () => {\n  const counter = useRef(0)\n  const [last, setLast] = useState(WAIT_MESSAGE)\n\n  const nextRequest = async (request) => {\n    const current = ++counter.current\n    setLast(WAIT_MESSAGE)\n    let message\n    try {\n      const res = await request()\n      const data = (res.ok && await res.json()) || { message: `Error code ${res.status}: ${res.statusText}` }\n      message = data.message\n    } catch (e) {\n      message = String(e)\n    }\n\n    if (current !== counter.current) {\n      return\n    }\n    setLast(message)\n  }\n\n  useEffect(() => {\n    nextRequest(() => fetch("http://localhost:8080/"))\n    return () => counter.current = Infinity\n  }, [])\n\n  const onSubmit = async (value) => {\n    await nextRequest(() => fetch("http://localhost:8080/contacts", {\n      method: \'POST\',\n      headers: {\n        \'Accept\': \'application/json\',\n        \'Content-Type\': \'application/json\'\n      },\n      body: JSON.stringify(value)\n    }))\n  }\n\n  return (\n    <div className="App">\n      <header className="App-header">\n        <h1>Contact Us</h1>\n        <p>{last}</p>\n\n        <Form onSubmit={onSubmit}>\n          <Field label={"First name"} name="first_name" required>{({ fieldProps }) => <TextField {...fieldProps} />}</Field>\n          <Field label={"Last name"} name="last_name">{({ fieldProps }) => <TextField {...fieldProps} />}</Field>\n          <Field label={"Address"} name="address" >{({ fieldProps }) => <TextField {...fieldProps} />}</Field>\n          <Field label={"Phone"} name="phone">{({ fieldProps }) => <TextField {...fieldProps} />}</Field>\n          <Field label={"Email"} name="email" required email>{({ fieldProps }) => <TextField {...fieldProps} />}</Field>\n          <Field label={"Message"} name="message" required>{({ fieldProps }) => <Textarea {...fieldProps} />}</Field>\n          <input type="submit" value="Submit" />\n        </Form>\n      </header>\n    </div>\n  )\n}\n')),o.a.createElement(l.MDXTag,{name:"p",components:t},"This code clarifies our requirements. Component sends requests to server to obtain server status and to save new user messages. POST and GET requests are sent to the server using ",o.a.createElement(l.MDXTag,{name:"inlineCode",components:t,parentName:"p"},"fetch")," function. Status of the last communication with the server is stored and displayed using ",o.a.createElement(l.MDXTag,{name:"inlineCode",components:t,parentName:"p"},"const [last, setLast] = useState(WAIT_MESSAGE)")," state variable. Stale replies are handled using counter (",o.a.createElement(l.MDXTag,{name:"inlineCode",components:t,parentName:"p"},"const counter = useRef(0)"),"). Also asynchronous updates on unmounted component (giving warning messages in development) are avoided using ",o.a.createElement(l.MDXTag,{name:"inlineCode",components:t,parentName:"p"},"useEffect")," clean up function (",o.a.createElement(l.MDXTag,{name:"inlineCode",components:t,parentName:"p"},"return () => counter.current = Infinity"),"). Now when the scope of component functionality became clear, it is time to proceed to the actual development."),o.a.createElement(l.MDXTag,{name:"h2",components:t},"Jest: mocking ",o.a.createElement(l.MDXTag,{name:"inlineCode",components:t,parentName:"h2"},"fetch")," function"),o.a.createElement(l.MDXTag,{name:"p",components:t},"The component under consideration needs to deal with application logic (belongs to the Domain layer according to ",o.a.createElement(l.MDXTag,{name:"a",components:t,parentName:"p",props:{href:"/posts/ddd-in-react/",title:"Domain Driven Design in React apps"}},"onion architecture terminology"),"). So it is better to start development from BDD style user stories. Lets compile the list of the most important use cases. First of all, upon the visit to the page, users should see the last request status (both in case of success and failures). Secondly, the form should validate fields (displaying error messages). And, finally, form should send valid requests to the server."),o.a.createElement(l.MDXTag,{name:"p",components:t},"As we do not want to depend on server implementation during development, we will want to stub ",o.a.createElement(l.MDXTag,{name:"inlineCode",components:t,parentName:"p"},"fetch")," requests. Which is, luckily quite simple. For example, to mock successful server replies, I have created simple helper function:"),o.a.createElement(l.MDXTag,{name:"pre",components:t},o.a.createElement(l.MDXTag,{name:"code",components:t,parentName:"pre",props:{className:"language-javascript"}},"const mockFetch = (response) => {\n  const mockResponseData = response\n\n  const mockJsonPromise = Promise.resolve(mockResponseData)\n  const mockResponsePromise = Promise.resolve({\n    ok: true,\n    json: () => mockJsonPromise,\n  })\n\n  jest.spyOn(global, 'fetch').mockImplementation(() => mockResponsePromise)\n}\n")),o.a.createElement(l.MDXTag,{name:"p",components:t},"A call to the ",o.a.createElement(l.MDXTag,{name:"inlineCode",components:t,parentName:"p"},"fetch")," function returns Promise, resolving to a response with ",o.a.createElement(l.MDXTag,{name:"inlineCode",components:t,parentName:"p"},"ok")," flag to test the success, and the number of asynchronous functions to fetch data. For this reason, the code above uses two promises. The mock itself is set using the jest ",o.a.createElement(l.MDXTag,{name:"inlineCode",components:t,parentName:"p"},"spyOn")," function. As a ",o.a.createElement(l.MDXTag,{name:"inlineCode",components:t,parentName:"p"},"fetch")," function is defined on a global object, we use it as a first argument to our mocking function - ",o.a.createElement(l.MDXTag,{name:"inlineCode",components:t,parentName:"p"},"jest.spyOn(global, 'fetch').mockImplementation(() => mockResponsePromise)"),". Mocking ",o.a.createElement(l.MDXTag,{name:"inlineCode",components:t,parentName:"p"},"fetch")," failures is even simpler one-liner:"),o.a.createElement(l.MDXTag,{name:"pre",components:t},o.a.createElement(l.MDXTag,{name:"code",components:t,parentName:"pre",props:{className:"language-javascript"}},"jest.spyOn(global, 'fetch').mockImplementation(() => { throw new Error(\"Some error\") })\n")),o.a.createElement(l.MDXTag,{name:"p",components:t},"Using these helpers, writing, for example, first test scenarios is quite simple:"),o.a.createElement(l.MDXTag,{name:"pre",components:t},o.a.createElement(l.MDXTag,{name:"code",components:t,parentName:"pre",props:{className:"language-javascript"}},"describe(\"user opens contact us\", () => {\n  it('API is active', async () => {\n    await act(async () => {\n      mockFetch({\n        message: 'API Active'\n      })\n\n      const { getByText } = render(<App />)\n\n      await waitForElement(() => getByText(/API Active/i))\n      expect(global.fetch.mock.calls.length).toBe(1)\n      global.fetch.mockRestore()\n    })\n  })\n\n  it('API failure', async () => {\n    await act(async () => {\n      jest.spyOn(global, 'fetch').mockImplementation(() => { throw new Error(\"Some error\") })\n      const { getByText } = render(<App />)\n\n      await waitForElement(() => getByText(/Error: Some error/i))\n      expect(global.fetch.mock.calls.length).toBe(1)\n      global.fetch.mockRestore()\n    })\n  })\n})\n")),o.a.createElement(l.MDXTag,{name:"p",components:t},"Test cases begin from ",o.a.createElement(l.MDXTag,{name:"inlineCode",components:t,parentName:"p"},"fetch")," mocking (original fetch implementation is restored at the end of ech test). A popular ",o.a.createElement(l.MDXTag,{name:"inlineCode",components:t,parentName:"p"},"@testing-library/react")," library helps to avoid unnecessary tight coupling between tests and application, giving us ability quite flexibly reference sub-components. As ",o.a.createElement(l.MDXTag,{name:"inlineCode",components:t,parentName:"p"},"App")," component is updated asynchronously, as a result of call to the server, tests are wrapped by ",o.a.createElement(l.MDXTag,{name:"inlineCode",components:t,parentName:"p"},"await act(async () => {...})")," functions. We wait for UI updates using ",o.a.createElement(l.MDXTag,{name:"inlineCode",components:t,parentName:"p"},"await waitForElement(() => ...)")," wrappers."),o.a.createElement(l.MDXTag,{name:"h2",components:t},"Next"),o.a.createElement(l.MDXTag,{name:"p",components:t},"Form validation could be tested similarly. It is even simpler, as there is no need to mock ",o.a.createElement(l.MDXTag,{name:"inlineCode",components:t,parentName:"p"},"fetch")," or wait for asynchronous UI updates. Just simulate user input using ",o.a.createElement(l.MDXTag,{name:"inlineCode",components:t,parentName:"p"},"fireEvent.click")," and ",o.a.createElement(l.MDXTag,{name:"inlineCode",components:t,parentName:"p"},"fireEvent.change")," testing library functions:"),o.a.createElement(l.MDXTag,{name:"pre",components:t},o.a.createElement(l.MDXTag,{name:"code",components:t,parentName:"pre",props:{className:"language-javascript"}},"describe(\"form validation errors\", () => {\n  it('empty', () => {\n\n    const { getByText, getAllByText } = render(<App />)\n\n    fireEvent.click(getByText(/Submit/i))\n    const errors = getAllByText(/required/i)\n    expect(errors.length).toBe(3)\n  })\n\n  it('wrong email', () => {\n\n    const { getByText, getAllByText, getByLabelText } = render(<App />)\n\n    fireEvent.change(getByLabelText(/Email/i), { target: { value: 'email' } })\n    fireEvent.click(getByText(/Submit/i))\n\n    expect(getAllByText(/required/i).length).toBe(2)\n    expect(getAllByText(/valid email/i).length).toBe(1)\n  })\n})\n")),o.a.createElement(l.MDXTag,{name:"p",components:t},"Request helper ",o.a.createElement(l.MDXTag,{name:"inlineCode",components:t,parentName:"p"},"nextRequest")," and other request handling machinery do not really belong to the component and eventually should be moved (and tested) to a separate, more generic React Hook (which could be postponed until our application becomes bigger)."),o.a.createElement(l.MDXTag,{name:"p",components:t},"Now, when the main functionality is tested, one may wish to look at the ",o.a.createElement(l.MDXTag,{name:"a",components:t,parentName:"p",props:{href:"/posts/mysql-express/",title:"Express and MySql. Simple Contact Us form"}},"server side implementation")," and test our form on real (development) server. To automate this process we may wish, eventually, to write integration tests."))},t}(o.a.Component),p=n(757);function u(e){return o.a.createElement(p.a,e,o.a.createElement(m,e))}n.d(t,"default",function(){return u})},737:function(e,t,n){"use strict";n(46);var a=n(738),o=n(0),r=n.n(o),s=n(2),i=n.n(s),c=n(748),l=n.n(c),m=n(34);function p(e){var t=e.description,n=e.lang,o=e.meta,s=e.keywords,i=e.title;return r.a.createElement(m.b,{query:u,render:function(e){return"string"==typeof s&&(s=s.split(",").map(function(e){return e.trim()})),t=t||e.site.siteMetadata.description,r.a.createElement(l.a,{htmlAttributes:{lang:n},title:i,titleTemplate:"%s | "+e.site.siteMetadata.project,meta:[{name:"description",content:t},{property:"og:title",content:i},{property:"og:description",content:t},{property:"og:type",content:"website"},{name:"twitter:card",content:"summary"},{name:"twitter:creator",content:e.site.siteMetadata.author},{name:"twitter:title",content:i},{name:"twitter:description",content:t}].concat(s?{name:"keywords",content:s.join(", ")}:[]).concat(o)})},data:a})}p.defaultProps={lang:"en",meta:[],keywords:null},p.propTypes={description:i.a.string,lang:i.a.string,meta:i.a.array,keywords:i.a.oneOfType([i.a.string,i.a.arrayOf(i.a.string)]),title:i.a.string.isRequired},t.a=p;var u="304502870"},738:function(e){e.exports={data:{site:{siteMetadata:{project:"ACT blog",description:"React, Ant Design, Gatsby, GraphQl, and other web technologies",author:"Act Labs"}}}}},739:function(e,t,n){"use strict";n.d(t,"a",function(){return l});n(352);var a=n(740),o=n(0),r=n.n(o),s=n(34),i=n(231),c=n.n(i);function l(){return r.a.createElement(s.b,{query:"2369744027",render:function(e){return r.a.createElement(c.a,{fixed:e.logo.childImageSharp.fixed,style:{float:"left"}})},data:a})}},740:function(e){e.exports={data:{logo:{childImageSharp:{fixed:{base64:"data:image/png;base64,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",width:50,height:60,src:"/static/a64620346ac3ce8d4580a3f07039fa3c/8469d/logo.png",srcSet:"/static/a64620346ac3ce8d4580a3f07039fa3c/8469d/logo.png 1x"}}}}}},741:function(e){e.exports={data:{config:{copyright:"Copyright © Act Labs",social:[{icon:"facebook",link:"https://www.facebook.com/ACT7LAB"},{icon:"github",link:"https://github.com/act-labs/gatsby-starter-act-blog"}]}}}},742:function(e){e.exports={data:{config:{nav:[{text:"home",slug:null},{text:"posts",slug:"/posts/"},{text:"snippets",slug:"/snippets/"}]}}}},743:function(e,t,n){"use strict";n(6);var a=n(138),o=(n(178),n(31)),r=n.n(o),s=(n(749),n(735),n(736)),i=n.n(s),c=n(741),l=n(0),m=n.n(l),p=n(34),u=i.a.Footer;function d(e){var t=e.social,n=e.copyright,o=t.map(function(e){var t=e.link,n=e.icon;return m.a.createElement(a.a,{key:n,to:t},m.a.createElement(r.a,{type:n,style:{fontSize:"24px",marginLeft:10,color:"rgba(0, 0, 0, 0.65)"}}))});return m.a.createElement(u,{style:{textAlign:"center"}},m.a.createElement("div",null,n,m.a.createElement("div",{style:{float:"right"}},o)))}function g(e){return e.social?m.a.createElement(d,e):m.a.createElement(p.b,{query:"2743462859",render:function(t){var n=t.config,a=n.social,o=n.copyright;return m.a.createElement(d,Object.assign({social:a,copyright:o},e))},data:c})}n(747);var f=n(746),h=n.n(f),y=n(739),E=n(742),v=i.a.Header;function b(e){var t=e.nav;return m.a.createElement(v,{className:"navigation-bar"},m.a.createElement(a.a,{to:"/"},m.a.createElement(y.a,null)),m.a.createElement(h.a,{theme:"dark",mode:"horizontal",defaultSelectedKeys:t.filter(function(e){return e.selected}).map(function(e){return e.text}),style:{lineHeight:"64px"}},t.map(function(e,t){var n=e.slug,o=e.text;return m.a.createElement(h.a.Item,{key:t},m.a.createElement(a.a,{to:n||"/"},o))})))}function T(e){return e.nav?m.a.createElement(b,e):m.a.createElement(p.b,{query:"1250442554",render:function(t){var n=t.config.nav;return m.a.createElement(b,Object.assign({nav:n},e))},data:E})}var w=n(737),M=n(14),A=n.n(M);n(671);n.d(t,"a",function(){return k});var D=i.a.Content,x=i.a.Sider;function X(e){var t=e.style,n=e.children,a=A()(e,["style","children"]);return m.a.createElement(D,Object.assign({style:Object.assign({padding:"5px 24px"},t)},a),n)}function k(e){var t=e.children,n=e.className,a=e.title,o=e.description,r=e.keywords,s=e.style,c=e.layout,l=Object.assign({},N,c),p=l.footer,u=l.fullHeight,d=Object.assign({},u?{height:"100%"}:null,s),f=(n?n+" ":"")+"page-layout";return m.a.createElement(i.a,{className:f,style:d},m.a.createElement(w.a,{title:a,keywords:r,description:o}),m.a.createElement(T,null),t,p?m.a.createElement(g,null):null)}var N={footer:!0};k.Panel=X,k.SideMenuPanel=function(e){var t=e.children,n=e.menu;return m.a.createElement(i.a,{style:{padding:"1em 0",background:"#fff",minHeight:1e3}},m.a.createElement(x,{width:200},n),m.a.createElement(X,null,t))}},745:function(e,t,n){"use strict";n(6);var a=n(138),o=(n(46),n(0)),r=n.n(o),s=n(891),i=n(751),c=n(752),l=n(753),m=n(754),p=n(755),u=n(756);s.a.registerLanguage("javascript",i.a),s.a.registerLanguage("sh",c.a),s.a.registerLanguage("markdown",l.a),s.a.registerLanguage("yaml",m.a),s.a.registerLanguage("dockerfile",p.a);var d=n(1);n.d(t,"a",function(){return f});var g={components:{code:function(e){var t="bash";if(e.className){var n=e.className.split("-");n.length>1&&(t=n[1])}return r.a.createElement(s.a,{language:t,style:u.github},e.children)},a:a.a}};function f(e){var t=Object.assign({},g,e),n=t.components,a=t.children;return r.a.createElement(d.MDXProvider,{components:n},a)}},757:function(e,t,n){"use strict";n.d(t,"a",function(){return c});var a=n(745),o=(n(6),n(743)),r=n(0),s=n.n(r),i=(n(672),o.a.Panel);function c(e){var t=e.children,n=e.pageContext,r=Object.assign({frontmatter:{}},n),c=Object.assign({},{layout:r.layout},r.frontmatter);return s.a.createElement(o.a,c,s.a.createElement(i,{style:{paddingTop:"1em"}},c.title?s.a.createElement("h1",null,c.title):null,s.a.createElement(a.a,null,t)))}}}]);
//# sourceMappingURL=component---src-generated-posts-contact-us-form-js-20f412199bbb063c7a0f.js.map